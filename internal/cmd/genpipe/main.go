package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
)

type method struct {
	name   string
	params string
	args   string
}

func main() {
	in := flag.String("in", "", "input file")
	out := flag.String("out", "", "output file")
	flag.Parse()

	if *in == "" || *out == "" {
		os.Exit(2)
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *in, nil, 0)
	if err != nil {
		panic(err)
	}

	methods := collectMethods(fset, file)
	buf := &bytes.Buffer{}
	buf.WriteString("// Code generated by genpipe; DO NOT EDIT.\n")
	buf.WriteString("package money\n\n")

	for _, m := range methods {
		buf.WriteString("func (p Pipe) ")
		buf.WriteString(m.name)
		buf.WriteString("(")
		buf.WriteString(m.params)
		buf.WriteString(") Pipe {\n")
		buf.WriteString("\tif p.err != nil {\n\t\treturn p\n\t}\n")
		buf.WriteString("\tm, err := p.money.")
		buf.WriteString(m.name)
		buf.WriteString("(")
		buf.WriteString(m.args)
		buf.WriteString(")\n")
		buf.WriteString("\tif err != nil {\n\t\treturn Pipe{money: p.money, err: err}\n\t}\n")
		buf.WriteString("\treturn Pipe{money: m}\n")
		buf.WriteString("}\n\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	if err := os.WriteFile(*out, formatted, 0o644); err != nil {
		panic(err)
	}
}

func collectMethods(fset *token.FileSet, file *ast.File) []method {
	var out []method
	for _, decl := range file.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv == nil || fn.Name == nil {
			continue
		}
		if !isMoneyReceiver(fn.Recv) {
			continue
		}
		if !returnsMoneyError(fn.Type.Results) {
			continue
		}
		params, args := renderParams(fset, fn.Type.Params)
		out = append(out, method{name: fn.Name.Name, params: params, args: args})
	}
	return out
}

func isMoneyReceiver(recv *ast.FieldList) bool {
	if recv == nil || len(recv.List) != 1 {
		return false
	}
	field := recv.List[0]
	ident, ok := field.Type.(*ast.Ident)
	if !ok {
		return false
	}
	return ident.Name == "Money"
}

func returnsMoneyError(results *ast.FieldList) bool {
	if results == nil || len(results.List) != 2 {
		return false
	}
	first, ok := results.List[0].Type.(*ast.Ident)
	if !ok || first.Name != "Money" {
		return false
	}
	second, ok := results.List[1].Type.(*ast.Ident)
	if !ok || second.Name != "error" {
		return false
	}
	return true
}

func renderParams(fset *token.FileSet, params *ast.FieldList) (string, string) {
	if params == nil || len(params.List) == 0 {
		return "", ""
	}
	paramBuf := &bytes.Buffer{}
	argBuf := &bytes.Buffer{}
	argIndex := 0

	for i, field := range params.List {
		nameList := field.Names
		typeStr := exprString(fset, field.Type)
		if len(nameList) == 0 {
			name := "arg" + itoa(argIndex)
			argIndex++
			if i > 0 {
				paramBuf.WriteString(", ")
			}
			paramBuf.WriteString(name)
			paramBuf.WriteString(" ")
			paramBuf.WriteString(typeStr)
			if argBuf.Len() > 0 {
				argBuf.WriteString(", ")
			}
			argBuf.WriteString(name)
			continue
		}
		for j, name := range nameList {
			if i > 0 || j > 0 {
				paramBuf.WriteString(", ")
			}
			paramBuf.WriteString(name.Name)
			paramBuf.WriteString(" ")
			paramBuf.WriteString(typeStr)
			if argBuf.Len() > 0 {
				argBuf.WriteString(", ")
			}
			argBuf.WriteString(name.Name)
		}
	}
	return paramBuf.String(), argBuf.String()
}

func exprString(fset *token.FileSet, expr ast.Expr) string {
	buf := &bytes.Buffer{}
	_ = printer.Fprint(buf, fset, expr)
	return buf.String()
}

func itoa(n int) string {
	if n == 0 {
		return "0"
	}
	var buf [20]byte
	i := len(buf)
	for n > 0 {
		i--
		buf[i] = byte('0' + n%10)
		n /= 10
	}
	return string(buf[i:])
}
